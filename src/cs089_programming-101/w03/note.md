# [CODE SPITZ 89] PROGRAMMING 101 3회차

- [강의 링크][link]

[link]: https://www.youtube.com/watch?v=v5Dl1C-5uRY

## I. 제어문

- 코드를 잘 못 짜는 이유 중 하나는 복잡한 for 문을 잘 못 쓸 뿐 아니라, if 문, if-else 문, switch 문을 잘못 사용하기 때문에 여러가지 문제가 발생한다.

### 1. if 문
- optional와 shield 두가지 경우에 사용한다.
- shield의 경우 throw or return 문을 포함한다.

### 2. if-else 문, 삼항 연산자
- binary mandatory(이지선다)
- 둘 중 하나의 경우가 필수적으로 발생해야 하는 경우에 사용한다.
- 두 분기는 병렬 조건(의미론상 같은 행위)이어야 한다.
```js
if (!Array.isArray(arr)) throw 'invalid arr'; // shield

if (arr.length === 0) return '[]';
else return stringify(arr);

// 또는
return arr.length === 0 ? '[]' : stringify(arr);
```
- 코틀린이나 루비 등 언어는 `return if (...) 0 else 1` 과 같이 문법에서 병렬 제어를 보장한다.
- 반면 자바스크립트는 문법에서 병렬 제어를 보장하지 않기 때문에, 다음과 같이 부가적인 장치가 필요하다.
```js
const EMPTY = {}; // 고유한 값을 사용하기 위해 객체 할당
let rtn = EMPTY;

if (arr.length === 0) rtn = '[]';
else rtn = stringify(arr);

if (rtn === EMPTY) throw 'no processed';
return rtn;
```

### 3. switch 문
- multiple mandatory
- 자바스크립트에서는 표현식과 조건 분기를 switch로 동시에 표현할 수 없어서 다음과 같이 사용할 수 있다.
- switch 문을 사용할 때는 발생할 수 있는 모든 경우가 처리되어야 한다.
```js
switch (true) {
  case arr.length === 0: return '[]';
  case arr.length > 0: return stringify(arr);
  default: throw 'exception';
}
```

### 4. while 문
- recursive
- 사전에 계획되지 않은 반복으로, 반복할 때마다 다음 반복을 계산한다.

### 5. for 문
- iteration
- 사전에 계획된 반복으로, 이미 반복을 어떻게 할지 계획되어 있다.

## II. OCP

- Open Closed Principle
- (교수님께서 가라사대) SOLID 원칙 중 제일 중요한 원칙이다.
- 좋은 코드인지 아닌지는 한마디로 말해서 OCP의 준수 상태를 보면 알 수 있다.
- 코드가 확정적이면 OCP를 준수하지 않아도 되자만, 프로그래밍 역사상 그러한 코드는 없었다.
- 수정에는 닫혀 있고, 확장에는 열려 있다.
- 모듈, 코드, 패키지 등 다양한 레벨에서 일어나며, 각각의 경우마다 의미가 다르다.

### 1. 코드 레벨 OCP
- 코드 수정에는 닫혀있고, 케이스(if-else 문, switch 문의 병렬조건) 확장에는 열려있어야 한다.
- switch 문을 사용하지 않는다. 혹은 if-else 문인줄 알았는데 케이스가 추가될 수 있다.
- if-else 문, switch 문에서는 케이스를 확장하기 위해서 대상이 되는 함수의 코드를 수정해야 한다.

### 2. 커맨드 패턴
- OCP는 일반적으로 커맨드 패턴으로 달성된다.
- 가장 쉽게 OCP를 달성하는 방법은 라우터와 라우팅 테이블을 만드는 것이다.
- 커맨드 객체(메소드가 하나뿐인 객체) 또는 람다를 통해 제어문을 식으로 바꾼다.
- 제어와 값이 따로 놀지 않도록, 라우터와 라우팅 테이블(데이터) 코드는 응집되어야 한다.
```js
const myJSON = {
  // router에서 사용하는 전략 객체
  number: v => v.toString(),
  boolean: v => v.toString(),
  string: v => `"${v}"`,
  // router
  stirngify(v) {
    return this[typeof v]?.(v) ?? 'null';
  }
};

const escapeChk = {
  table: [[/[\r\n\l]/g, '\\n'], [/"/g, '\\\"'], [/\t/g, '\\t']],
  convertRouter(v) {
    return this.table.reduce((acc, curr) => acc.replace(...curr), v);
  }
};
```
- 1. 모든 케이스는 반드시 라우터와 라우팅 테이블로 대체할 수 있다.
- 2. 라우터는 반드시 mandatory 이어야 한다(해당하는 조건이 없는 경우 throw).

## III. OCP와 IoC

### 1. IoC
- Inversion of Control
- 정당한 이유로 사용된 제어 로직(if 문)은 도메인 그 자체이기 때문에 제거할 수 없다.
- 제어를 제거할 수 없다면, 제어를 중복해서 등장하지 않게 하는 것이 목표가 되어야 한다.
- 제어 로직을 여러 곳에서 등장하지 않게 하고, 특정 도메인 로직을 수행해야 할 때는 로직이 위임된 함수를 사용하도록 해야 한다. 
- 다른 코드에서는 제어를 모두 제거하고, 특정 함수가 제어를 유일하게 갖도록 하는 것이 제어의 역전(IoC)이다.
- 유일하게 제어를 갖는 함수를 제어 센터(control center)라고 한다.
- 모든 상황에서 함수를 만드는 것은 반복되는 제어를 제거하기 위한 제어 센터를 만드는 행위이다.

### 2. 커맨드 패턴과 변화율
- 모든 케이스는 커맨드 패턴을 통해 반드시 라우터와 라우팅 테이블로 대체할 수 있고, 라우터는 제어 센터 열할을 수행한다.
- 라우터 코드를 수정해야 하는 상황이 발생하면 OCP는 깨지고, 필요에 따라 중첩되는 라우터와 라우팅 테이블을 만들어야 한다.
- 대신에 각각의 라우터가 제어하는 수준에서는 코드 수정 없이 라우팅 테이블을 통해 케이스를 확장할 수 있다.
- 변화율에 따라 코드의 역할 모델을 나누면 유지보수하기 좋아진다.
- 라우터는 라우팅 테이블 보다 상대적으로 변화율이 낮고, 라우팅 테이블은 라우터 보다 상대적으로 변화율이 높다.
- 라우팅 테이블이 확장되는 동안에는 라우터를 수정하지 않아도 되지만, 라우터를 수정해야 하면 라우팅 테이블까지 전면 검토해야 한다(유지보수 측면의 트랜잭션).

### 3. 정리
- 정당한 if 문은 절대로 사라지지 않는다.
- 변화율에 따라(변화율이 동일한 코드끼리 묶어서) OCP를 준수하면 관리성(유지보수성)이 좋아진다.
- if 문의 단계별 구성요소를 분석해서 변화율에 따라 OCP를 준수할 수 있는 라우터와 라우팅 테이블로 번역한다.

## IV. 코드 디자인

- 코드를 작성할 때, 설계 또는 디자인이란, 유지보수 및 기능 추가 등에 유리하도록 코드를(함수, 클래스, 객체 등의 구조물을 이용해서) 재배치하는 것이다.
- 본 강의는 코드 작성시 설계(디자인) 의사결정을 배우는 과정이다.
- 구체적으로는 언어를 의도(유지보수성이 높아지는 디자인)에 맞게 사용하는 법을 배우는 것이다.
- 디자인 의도(의사결정)는 코드로 완전히 표현된다(뉘앙스 까지도).
- 개발자끼리는 코드만으로 의사소통 할 수 있어야 한다.
- 제어문을 잘 짜는 스킬과 더불어, 개발자라면 반드시 익혀야 하는 스킬이다.

## V. 마무리

### 1. 과제
- `[1, 2, ["a", [1, 2], false], 3, ["b", "c", [1, 2]]]` 를 stringify 한다.
- 꼬리 재귀와 루프 방식 두 종류로 구현한다.
- ds stack을 활용한다.
- 전지적 시점으로 알고리즘을 작성하는 방식(복잡한 문제를 한번에 제어문으로 작성하기)은 문제가 조금만 복잡해져도 사용하기 힘들다.
- 귀납적 사고 방식으로 도메인 지식을 파악한다(한국어로 정확하게 일반화 특성을 명시할 수 있을 정도로).
- 각 원소가 도출되는 모든 경우의 수를 파악하고, 모든 원소의 공통점(속성)을 찾아 패턴화한다.
- 현상을 보고 연역적으로 일반화된 원리를 찾는다(연역적 사고 === 추론 === 패턴 발견 === IQ === 프로그래밍 가능 === 훈련을 통해 향상시킬 수 있는 분야).
- 수학은 이러한 사고를 연습시킨다.
- 귀납적 프로그래밍 과정
  1. `무엇을 반복`해서 만들어지는지 파악
  2. 각 반복은 `이전 값`을 어떻게 이용해서 현재 값이 나왔는지 파악
  3. 점화식 도출
  4. 재귀
  5. 꼬리 재귀 최적화
  6. 기계적으로 루프 문으로 번역
